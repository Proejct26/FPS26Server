// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace game {
class CS_Attack;
struct CS_AttackDefaultTypeInternal;
extern CS_AttackDefaultTypeInternal _CS_Attack_default_instance_;
class CS_ChangeWeapon;
struct CS_ChangeWeaponDefaultTypeInternal;
extern CS_ChangeWeaponDefaultTypeInternal _CS_ChangeWeapon_default_instance_;
class CS_MoveStart;
struct CS_MoveStartDefaultTypeInternal;
extern CS_MoveStartDefaultTypeInternal _CS_MoveStart_default_instance_;
class CS_MoveStop;
struct CS_MoveStopDefaultTypeInternal;
extern CS_MoveStopDefaultTypeInternal _CS_MoveStop_default_instance_;
class CS_OnAccept;
struct CS_OnAcceptDefaultTypeInternal;
extern CS_OnAcceptDefaultTypeInternal _CS_OnAccept_default_instance_;
class CS_Sync;
struct CS_SyncDefaultTypeInternal;
extern CS_SyncDefaultTypeInternal _CS_Sync_default_instance_;
class SC_Attack;
struct SC_AttackDefaultTypeInternal;
extern SC_AttackDefaultTypeInternal _SC_Attack_default_instance_;
class SC_ChangeWeapon;
struct SC_ChangeWeaponDefaultTypeInternal;
extern SC_ChangeWeaponDefaultTypeInternal _SC_ChangeWeapon_default_instance_;
class SC_CreateMyCharacter;
struct SC_CreateMyCharacterDefaultTypeInternal;
extern SC_CreateMyCharacterDefaultTypeInternal _SC_CreateMyCharacter_default_instance_;
class SC_CreateOtherCharacter;
struct SC_CreateOtherCharacterDefaultTypeInternal;
extern SC_CreateOtherCharacterDefaultTypeInternal _SC_CreateOtherCharacter_default_instance_;
class SC_Damage;
struct SC_DamageDefaultTypeInternal;
extern SC_DamageDefaultTypeInternal _SC_Damage_default_instance_;
class SC_DeleteCharacter;
struct SC_DeleteCharacterDefaultTypeInternal;
extern SC_DeleteCharacterDefaultTypeInternal _SC_DeleteCharacter_default_instance_;
class SC_MoveStart;
struct SC_MoveStartDefaultTypeInternal;
extern SC_MoveStartDefaultTypeInternal _SC_MoveStart_default_instance_;
class SC_MoveStop;
struct SC_MoveStopDefaultTypeInternal;
extern SC_MoveStopDefaultTypeInternal _SC_MoveStop_default_instance_;
class SC_Sync;
struct SC_SyncDefaultTypeInternal;
extern SC_SyncDefaultTypeInternal _SC_Sync_default_instance_;
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::CS_Attack* Arena::CreateMaybeMessage<::game::CS_Attack>(Arena*);
template<> ::game::CS_ChangeWeapon* Arena::CreateMaybeMessage<::game::CS_ChangeWeapon>(Arena*);
template<> ::game::CS_MoveStart* Arena::CreateMaybeMessage<::game::CS_MoveStart>(Arena*);
template<> ::game::CS_MoveStop* Arena::CreateMaybeMessage<::game::CS_MoveStop>(Arena*);
template<> ::game::CS_OnAccept* Arena::CreateMaybeMessage<::game::CS_OnAccept>(Arena*);
template<> ::game::CS_Sync* Arena::CreateMaybeMessage<::game::CS_Sync>(Arena*);
template<> ::game::SC_Attack* Arena::CreateMaybeMessage<::game::SC_Attack>(Arena*);
template<> ::game::SC_ChangeWeapon* Arena::CreateMaybeMessage<::game::SC_ChangeWeapon>(Arena*);
template<> ::game::SC_CreateMyCharacter* Arena::CreateMaybeMessage<::game::SC_CreateMyCharacter>(Arena*);
template<> ::game::SC_CreateOtherCharacter* Arena::CreateMaybeMessage<::game::SC_CreateOtherCharacter>(Arena*);
template<> ::game::SC_Damage* Arena::CreateMaybeMessage<::game::SC_Damage>(Arena*);
template<> ::game::SC_DeleteCharacter* Arena::CreateMaybeMessage<::game::SC_DeleteCharacter>(Arena*);
template<> ::game::SC_MoveStart* Arena::CreateMaybeMessage<::game::SC_MoveStart>(Arena*);
template<> ::game::SC_MoveStop* Arena::CreateMaybeMessage<::game::SC_MoveStop>(Arena*);
template<> ::game::SC_Sync* Arena::CreateMaybeMessage<::game::SC_Sync>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {

enum PacketID : int {
  SC_CREATE_MY_CHARACTER = 0,
  SC_CREATE_OTHER_CHARACTER = 1,
  SC_DELETE_CHARACTER = 2,
  SC_MOVE_START = 11,
  SC_MOVE_STOP = 13,
  SC_CHANGEWEAPON = 15,
  SC_ATTACK = 21,
  SC_DAMAGE = 30,
  SC_SYNC = 251,
  SC_ECHO = 253,
  CS_MOVE_START = 10,
  CS_MOVE_STOP = 12,
  CS_CHANGEWEAPON = 14,
  CS_ATTACK = 20,
  CS_ONACCEPT = 100,
  CS_SYNC = 250,
  CS_ECHO = 252,
  PacketID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PacketID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PacketID_IsValid(int value);
constexpr PacketID PacketID_MIN = SC_CREATE_MY_CHARACTER;
constexpr PacketID PacketID_MAX = SC_ECHO;
constexpr int PacketID_ARRAYSIZE = PacketID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PacketID_descriptor();
template<typename T>
inline const std::string& PacketID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PacketID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PacketID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PacketID_descriptor(), enum_t_value);
}
inline bool PacketID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PacketID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PacketID>(
    PacketID_descriptor(), name, value);
}
// ===================================================================

class CS_OnAccept final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_OnAccept) */ {
 public:
  inline CS_OnAccept() : CS_OnAccept(nullptr) {}
  ~CS_OnAccept() override;
  explicit PROTOBUF_CONSTEXPR CS_OnAccept(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_OnAccept(const CS_OnAccept& from);
  CS_OnAccept(CS_OnAccept&& from) noexcept
    : CS_OnAccept() {
    *this = ::std::move(from);
  }

  inline CS_OnAccept& operator=(const CS_OnAccept& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_OnAccept& operator=(CS_OnAccept&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_OnAccept& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_OnAccept* internal_default_instance() {
    return reinterpret_cast<const CS_OnAccept*>(
               &_CS_OnAccept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CS_OnAccept& a, CS_OnAccept& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_OnAccept* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_OnAccept* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_OnAccept* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_OnAccept>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_OnAccept& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_OnAccept& from) {
    CS_OnAccept::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_OnAccept* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_OnAccept";
  }
  protected:
  explicit CS_OnAccept(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:game.CS_OnAccept)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_CreateMyCharacter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_CreateMyCharacter) */ {
 public:
  inline SC_CreateMyCharacter() : SC_CreateMyCharacter(nullptr) {}
  ~SC_CreateMyCharacter() override;
  explicit PROTOBUF_CONSTEXPR SC_CreateMyCharacter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_CreateMyCharacter(const SC_CreateMyCharacter& from);
  SC_CreateMyCharacter(SC_CreateMyCharacter&& from) noexcept
    : SC_CreateMyCharacter() {
    *this = ::std::move(from);
  }

  inline SC_CreateMyCharacter& operator=(const SC_CreateMyCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_CreateMyCharacter& operator=(SC_CreateMyCharacter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_CreateMyCharacter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_CreateMyCharacter* internal_default_instance() {
    return reinterpret_cast<const SC_CreateMyCharacter*>(
               &_SC_CreateMyCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SC_CreateMyCharacter& a, SC_CreateMyCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_CreateMyCharacter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_CreateMyCharacter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_CreateMyCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_CreateMyCharacter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_CreateMyCharacter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_CreateMyCharacter& from) {
    SC_CreateMyCharacter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_CreateMyCharacter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_CreateMyCharacter";
  }
  protected:
  explicit SC_CreateMyCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 8,
    kIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kPosZFieldNumber = 4,
    kRotateXFieldNumber = 5,
    kRotateYFieldNumber = 6,
    kRotateZFieldNumber = 7,
  };
  // string name = 8;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 posX = 2;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 3;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 4;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // uint32 rotateX = 5;
  void clear_rotatex();
  uint32_t rotatex() const;
  void set_rotatex(uint32_t value);
  private:
  uint32_t _internal_rotatex() const;
  void _internal_set_rotatex(uint32_t value);
  public:

  // uint32 rotateY = 6;
  void clear_rotatey();
  uint32_t rotatey() const;
  void set_rotatey(uint32_t value);
  private:
  uint32_t _internal_rotatey() const;
  void _internal_set_rotatey(uint32_t value);
  public:

  // uint32 rotateZ = 7;
  void clear_rotatez();
  uint32_t rotatez() const;
  void set_rotatez(uint32_t value);
  private:
  uint32_t _internal_rotatez() const;
  void _internal_set_rotatez(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_CreateMyCharacter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t id_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    uint32_t rotatex_;
    uint32_t rotatey_;
    uint32_t rotatez_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_CreateOtherCharacter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_CreateOtherCharacter) */ {
 public:
  inline SC_CreateOtherCharacter() : SC_CreateOtherCharacter(nullptr) {}
  ~SC_CreateOtherCharacter() override;
  explicit PROTOBUF_CONSTEXPR SC_CreateOtherCharacter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_CreateOtherCharacter(const SC_CreateOtherCharacter& from);
  SC_CreateOtherCharacter(SC_CreateOtherCharacter&& from) noexcept
    : SC_CreateOtherCharacter() {
    *this = ::std::move(from);
  }

  inline SC_CreateOtherCharacter& operator=(const SC_CreateOtherCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_CreateOtherCharacter& operator=(SC_CreateOtherCharacter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_CreateOtherCharacter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_CreateOtherCharacter* internal_default_instance() {
    return reinterpret_cast<const SC_CreateOtherCharacter*>(
               &_SC_CreateOtherCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SC_CreateOtherCharacter& a, SC_CreateOtherCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_CreateOtherCharacter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_CreateOtherCharacter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_CreateOtherCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_CreateOtherCharacter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_CreateOtherCharacter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_CreateOtherCharacter& from) {
    SC_CreateOtherCharacter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_CreateOtherCharacter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_CreateOtherCharacter";
  }
  protected:
  explicit SC_CreateOtherCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kPosZFieldNumber = 4,
    kRotateXFieldNumber = 5,
    kRotateYFieldNumber = 6,
    kRotateZFieldNumber = 7,
    kHpFieldNumber = 8,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 posX = 2;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 3;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 4;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // uint32 rotateX = 5;
  void clear_rotatex();
  uint32_t rotatex() const;
  void set_rotatex(uint32_t value);
  private:
  uint32_t _internal_rotatex() const;
  void _internal_set_rotatex(uint32_t value);
  public:

  // uint32 rotateY = 6;
  void clear_rotatey();
  uint32_t rotatey() const;
  void set_rotatey(uint32_t value);
  private:
  uint32_t _internal_rotatey() const;
  void _internal_set_rotatey(uint32_t value);
  public:

  // uint32 rotateZ = 7;
  void clear_rotatez();
  uint32_t rotatez() const;
  void set_rotatez(uint32_t value);
  private:
  uint32_t _internal_rotatez() const;
  void _internal_set_rotatez(uint32_t value);
  public:

  // uint32 hp = 8;
  void clear_hp();
  uint32_t hp() const;
  void set_hp(uint32_t value);
  private:
  uint32_t _internal_hp() const;
  void _internal_set_hp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_CreateOtherCharacter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    uint32_t rotatex_;
    uint32_t rotatey_;
    uint32_t rotatez_;
    uint32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_DeleteCharacter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_DeleteCharacter) */ {
 public:
  inline SC_DeleteCharacter() : SC_DeleteCharacter(nullptr) {}
  ~SC_DeleteCharacter() override;
  explicit PROTOBUF_CONSTEXPR SC_DeleteCharacter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_DeleteCharacter(const SC_DeleteCharacter& from);
  SC_DeleteCharacter(SC_DeleteCharacter&& from) noexcept
    : SC_DeleteCharacter() {
    *this = ::std::move(from);
  }

  inline SC_DeleteCharacter& operator=(const SC_DeleteCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_DeleteCharacter& operator=(SC_DeleteCharacter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_DeleteCharacter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_DeleteCharacter* internal_default_instance() {
    return reinterpret_cast<const SC_DeleteCharacter*>(
               &_SC_DeleteCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SC_DeleteCharacter& a, SC_DeleteCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_DeleteCharacter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_DeleteCharacter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_DeleteCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_DeleteCharacter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_DeleteCharacter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_DeleteCharacter& from) {
    SC_DeleteCharacter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_DeleteCharacter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_DeleteCharacter";
  }
  protected:
  explicit SC_DeleteCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_DeleteCharacter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_MoveStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_MoveStart) */ {
 public:
  inline CS_MoveStart() : CS_MoveStart(nullptr) {}
  ~CS_MoveStart() override;
  explicit PROTOBUF_CONSTEXPR CS_MoveStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_MoveStart(const CS_MoveStart& from);
  CS_MoveStart(CS_MoveStart&& from) noexcept
    : CS_MoveStart() {
    *this = ::std::move(from);
  }

  inline CS_MoveStart& operator=(const CS_MoveStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_MoveStart& operator=(CS_MoveStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_MoveStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_MoveStart* internal_default_instance() {
    return reinterpret_cast<const CS_MoveStart*>(
               &_CS_MoveStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CS_MoveStart& a, CS_MoveStart& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_MoveStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_MoveStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_MoveStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_MoveStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_MoveStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_MoveStart& from) {
    CS_MoveStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_MoveStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_MoveStart";
  }
  protected:
  explicit CS_MoveStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateAxisYFieldNumber = 1,
    kKeyWFieldNumber = 2,
    kKeyAFieldNumber = 3,
    kKeySFieldNumber = 4,
    kKeyDFieldNumber = 5,
    kPosXFieldNumber = 6,
    kPosYFieldNumber = 7,
    kPosZFieldNumber = 8,
  };
  // uint32 rotateAxisY = 1;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 keyW = 2;
  void clear_keyw();
  uint32_t keyw() const;
  void set_keyw(uint32_t value);
  private:
  uint32_t _internal_keyw() const;
  void _internal_set_keyw(uint32_t value);
  public:

  // uint32 keyA = 3;
  void clear_keya();
  uint32_t keya() const;
  void set_keya(uint32_t value);
  private:
  uint32_t _internal_keya() const;
  void _internal_set_keya(uint32_t value);
  public:

  // uint32 keyS = 4;
  void clear_keys();
  uint32_t keys() const;
  void set_keys(uint32_t value);
  private:
  uint32_t _internal_keys() const;
  void _internal_set_keys(uint32_t value);
  public:

  // uint32 keyD = 5;
  void clear_keyd();
  uint32_t keyd() const;
  void set_keyd(uint32_t value);
  private:
  uint32_t _internal_keyd() const;
  void _internal_set_keyd(uint32_t value);
  public:

  // uint32 posX = 6;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 7;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 8;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.CS_MoveStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t rotateaxisy_;
    uint32_t keyw_;
    uint32_t keya_;
    uint32_t keys_;
    uint32_t keyd_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_MoveStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_MoveStart) */ {
 public:
  inline SC_MoveStart() : SC_MoveStart(nullptr) {}
  ~SC_MoveStart() override;
  explicit PROTOBUF_CONSTEXPR SC_MoveStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_MoveStart(const SC_MoveStart& from);
  SC_MoveStart(SC_MoveStart&& from) noexcept
    : SC_MoveStart() {
    *this = ::std::move(from);
  }

  inline SC_MoveStart& operator=(const SC_MoveStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_MoveStart& operator=(SC_MoveStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_MoveStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_MoveStart* internal_default_instance() {
    return reinterpret_cast<const SC_MoveStart*>(
               &_SC_MoveStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SC_MoveStart& a, SC_MoveStart& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_MoveStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_MoveStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_MoveStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_MoveStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_MoveStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_MoveStart& from) {
    SC_MoveStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_MoveStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_MoveStart";
  }
  protected:
  explicit SC_MoveStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRotateAxisYFieldNumber = 2,
    kKeyWFieldNumber = 3,
    kKeyAFieldNumber = 4,
    kKeySFieldNumber = 5,
    kKeyDFieldNumber = 6,
    kPosXFieldNumber = 7,
    kPosYFieldNumber = 8,
    kPosZFieldNumber = 9,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 rotateAxisY = 2;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 keyW = 3;
  void clear_keyw();
  uint32_t keyw() const;
  void set_keyw(uint32_t value);
  private:
  uint32_t _internal_keyw() const;
  void _internal_set_keyw(uint32_t value);
  public:

  // uint32 keyA = 4;
  void clear_keya();
  uint32_t keya() const;
  void set_keya(uint32_t value);
  private:
  uint32_t _internal_keya() const;
  void _internal_set_keya(uint32_t value);
  public:

  // uint32 keyS = 5;
  void clear_keys();
  uint32_t keys() const;
  void set_keys(uint32_t value);
  private:
  uint32_t _internal_keys() const;
  void _internal_set_keys(uint32_t value);
  public:

  // uint32 keyD = 6;
  void clear_keyd();
  uint32_t keyd() const;
  void set_keyd(uint32_t value);
  private:
  uint32_t _internal_keyd() const;
  void _internal_set_keyd(uint32_t value);
  public:

  // uint32 posX = 7;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 8;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 9;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_MoveStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t rotateaxisy_;
    uint32_t keyw_;
    uint32_t keya_;
    uint32_t keys_;
    uint32_t keyd_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_MoveStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_MoveStop) */ {
 public:
  inline CS_MoveStop() : CS_MoveStop(nullptr) {}
  ~CS_MoveStop() override;
  explicit PROTOBUF_CONSTEXPR CS_MoveStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_MoveStop(const CS_MoveStop& from);
  CS_MoveStop(CS_MoveStop&& from) noexcept
    : CS_MoveStop() {
    *this = ::std::move(from);
  }

  inline CS_MoveStop& operator=(const CS_MoveStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_MoveStop& operator=(CS_MoveStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_MoveStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_MoveStop* internal_default_instance() {
    return reinterpret_cast<const CS_MoveStop*>(
               &_CS_MoveStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CS_MoveStop& a, CS_MoveStop& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_MoveStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_MoveStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_MoveStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_MoveStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_MoveStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_MoveStop& from) {
    CS_MoveStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_MoveStop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_MoveStop";
  }
  protected:
  explicit CS_MoveStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateAxisYFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kPosZFieldNumber = 4,
  };
  // uint32 rotateAxisY = 1;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 posX = 2;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 3;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 4;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.CS_MoveStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t rotateaxisy_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_MoveStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_MoveStop) */ {
 public:
  inline SC_MoveStop() : SC_MoveStop(nullptr) {}
  ~SC_MoveStop() override;
  explicit PROTOBUF_CONSTEXPR SC_MoveStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_MoveStop(const SC_MoveStop& from);
  SC_MoveStop(SC_MoveStop&& from) noexcept
    : SC_MoveStop() {
    *this = ::std::move(from);
  }

  inline SC_MoveStop& operator=(const SC_MoveStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_MoveStop& operator=(SC_MoveStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_MoveStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_MoveStop* internal_default_instance() {
    return reinterpret_cast<const SC_MoveStop*>(
               &_SC_MoveStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SC_MoveStop& a, SC_MoveStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_MoveStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_MoveStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_MoveStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_MoveStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_MoveStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_MoveStop& from) {
    SC_MoveStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_MoveStop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_MoveStop";
  }
  protected:
  explicit SC_MoveStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRotateAxisYFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
    kPosZFieldNumber = 5,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 rotateAxisY = 2;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 posX = 3;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 4;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 5;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_MoveStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t rotateaxisy_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_ChangeWeapon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_ChangeWeapon) */ {
 public:
  inline CS_ChangeWeapon() : CS_ChangeWeapon(nullptr) {}
  ~CS_ChangeWeapon() override;
  explicit PROTOBUF_CONSTEXPR CS_ChangeWeapon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_ChangeWeapon(const CS_ChangeWeapon& from);
  CS_ChangeWeapon(CS_ChangeWeapon&& from) noexcept
    : CS_ChangeWeapon() {
    *this = ::std::move(from);
  }

  inline CS_ChangeWeapon& operator=(const CS_ChangeWeapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_ChangeWeapon& operator=(CS_ChangeWeapon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_ChangeWeapon& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_ChangeWeapon* internal_default_instance() {
    return reinterpret_cast<const CS_ChangeWeapon*>(
               &_CS_ChangeWeapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CS_ChangeWeapon& a, CS_ChangeWeapon& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_ChangeWeapon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_ChangeWeapon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_ChangeWeapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_ChangeWeapon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_ChangeWeapon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_ChangeWeapon& from) {
    CS_ChangeWeapon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_ChangeWeapon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_ChangeWeapon";
  }
  protected:
  explicit CS_ChangeWeapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponFieldNumber = 1,
  };
  // uint32 weapon = 1;
  void clear_weapon();
  uint32_t weapon() const;
  void set_weapon(uint32_t value);
  private:
  uint32_t _internal_weapon() const;
  void _internal_set_weapon(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.CS_ChangeWeapon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t weapon_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ChangeWeapon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_ChangeWeapon) */ {
 public:
  inline SC_ChangeWeapon() : SC_ChangeWeapon(nullptr) {}
  ~SC_ChangeWeapon() override;
  explicit PROTOBUF_CONSTEXPR SC_ChangeWeapon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ChangeWeapon(const SC_ChangeWeapon& from);
  SC_ChangeWeapon(SC_ChangeWeapon&& from) noexcept
    : SC_ChangeWeapon() {
    *this = ::std::move(from);
  }

  inline SC_ChangeWeapon& operator=(const SC_ChangeWeapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ChangeWeapon& operator=(SC_ChangeWeapon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ChangeWeapon& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ChangeWeapon* internal_default_instance() {
    return reinterpret_cast<const SC_ChangeWeapon*>(
               &_SC_ChangeWeapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SC_ChangeWeapon& a, SC_ChangeWeapon& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ChangeWeapon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ChangeWeapon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ChangeWeapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ChangeWeapon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ChangeWeapon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ChangeWeapon& from) {
    SC_ChangeWeapon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ChangeWeapon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_ChangeWeapon";
  }
  protected:
  explicit SC_ChangeWeapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kWeaponFieldNumber = 2,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 weapon = 2;
  void clear_weapon();
  uint32_t weapon() const;
  void set_weapon(uint32_t value);
  private:
  uint32_t _internal_weapon() const;
  void _internal_set_weapon(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_ChangeWeapon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t weapon_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_Attack) */ {
 public:
  inline CS_Attack() : CS_Attack(nullptr) {}
  ~CS_Attack() override;
  explicit PROTOBUF_CONSTEXPR CS_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Attack(const CS_Attack& from);
  CS_Attack(CS_Attack&& from) noexcept
    : CS_Attack() {
    *this = ::std::move(from);
  }

  inline CS_Attack& operator=(const CS_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Attack& operator=(CS_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Attack* internal_default_instance() {
    return reinterpret_cast<const CS_Attack*>(
               &_CS_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CS_Attack& a, CS_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Attack& from) {
    CS_Attack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_Attack";
  }
  protected:
  explicit CS_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
    kAttackSuccessFieldNumber = 2,
  };
  // uint32 targetId = 1;
  void clear_targetid();
  uint32_t targetid() const;
  void set_targetid(uint32_t value);
  private:
  uint32_t _internal_targetid() const;
  void _internal_set_targetid(uint32_t value);
  public:

  // bool attackSuccess = 2;
  void clear_attacksuccess();
  bool attacksuccess() const;
  void set_attacksuccess(bool value);
  private:
  bool _internal_attacksuccess() const;
  void _internal_set_attacksuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:game.CS_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t targetid_;
    bool attacksuccess_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_Attack) */ {
 public:
  inline SC_Attack() : SC_Attack(nullptr) {}
  ~SC_Attack() override;
  explicit PROTOBUF_CONSTEXPR SC_Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Attack(const SC_Attack& from);
  SC_Attack(SC_Attack&& from) noexcept
    : SC_Attack() {
    *this = ::std::move(from);
  }

  inline SC_Attack& operator=(const SC_Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Attack& operator=(SC_Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Attack* internal_default_instance() {
    return reinterpret_cast<const SC_Attack*>(
               &_SC_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SC_Attack& a, SC_Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Attack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Attack& from) {
    SC_Attack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Attack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_Attack";
  }
  protected:
  explicit SC_Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRotateAxisYFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
    kPosZFieldNumber = 5,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 rotateAxisY = 2;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 posX = 3;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 4;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 5;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t rotateaxisy_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_Damage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_Damage) */ {
 public:
  inline SC_Damage() : SC_Damage(nullptr) {}
  ~SC_Damage() override;
  explicit PROTOBUF_CONSTEXPR SC_Damage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Damage(const SC_Damage& from);
  SC_Damage(SC_Damage&& from) noexcept
    : SC_Damage() {
    *this = ::std::move(from);
  }

  inline SC_Damage& operator=(const SC_Damage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Damage& operator=(SC_Damage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Damage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Damage* internal_default_instance() {
    return reinterpret_cast<const SC_Damage*>(
               &_SC_Damage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SC_Damage& a, SC_Damage& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Damage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Damage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Damage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Damage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Damage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Damage& from) {
    SC_Damage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Damage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_Damage";
  }
  protected:
  explicit SC_Damage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kDamageHPFieldNumber = 3,
  };
  // uint32 attackerId = 1;
  void clear_attackerid();
  uint32_t attackerid() const;
  void set_attackerid(uint32_t value);
  private:
  uint32_t _internal_attackerid() const;
  void _internal_set_attackerid(uint32_t value);
  public:

  // uint32 targetId = 2;
  void clear_targetid();
  uint32_t targetid() const;
  void set_targetid(uint32_t value);
  private:
  uint32_t _internal_targetid() const;
  void _internal_set_targetid(uint32_t value);
  public:

  // uint32 damageHP = 3;
  void clear_damagehp();
  uint32_t damagehp() const;
  void set_damagehp(uint32_t value);
  private:
  uint32_t _internal_damagehp() const;
  void _internal_set_damagehp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_Damage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t attackerid_;
    uint32_t targetid_;
    uint32_t damagehp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_Sync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CS_Sync) */ {
 public:
  inline CS_Sync() : CS_Sync(nullptr) {}
  ~CS_Sync() override;
  explicit PROTOBUF_CONSTEXPR CS_Sync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Sync(const CS_Sync& from);
  CS_Sync(CS_Sync&& from) noexcept
    : CS_Sync() {
    *this = ::std::move(from);
  }

  inline CS_Sync& operator=(const CS_Sync& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Sync& operator=(CS_Sync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Sync& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Sync* internal_default_instance() {
    return reinterpret_cast<const CS_Sync*>(
               &_CS_Sync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CS_Sync& a, CS_Sync& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Sync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Sync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Sync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Sync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Sync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Sync& from) {
    CS_Sync::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Sync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CS_Sync";
  }
  protected:
  explicit CS_Sync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateAxisYFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kPosZFieldNumber = 4,
  };
  // uint32 rotateAxisY = 1;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 posX = 2;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 3;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 4;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.CS_Sync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t rotateaxisy_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_Sync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SC_Sync) */ {
 public:
  inline SC_Sync() : SC_Sync(nullptr) {}
  ~SC_Sync() override;
  explicit PROTOBUF_CONSTEXPR SC_Sync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Sync(const SC_Sync& from);
  SC_Sync(SC_Sync&& from) noexcept
    : SC_Sync() {
    *this = ::std::move(from);
  }

  inline SC_Sync& operator=(const SC_Sync& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Sync& operator=(SC_Sync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Sync& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Sync* internal_default_instance() {
    return reinterpret_cast<const SC_Sync*>(
               &_SC_Sync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SC_Sync& a, SC_Sync& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Sync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Sync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Sync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Sync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Sync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Sync& from) {
    SC_Sync::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Sync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SC_Sync";
  }
  protected:
  explicit SC_Sync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRotateAxisYFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
    kPosZFieldNumber = 5,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 rotateAxisY = 2;
  void clear_rotateaxisy();
  uint32_t rotateaxisy() const;
  void set_rotateaxisy(uint32_t value);
  private:
  uint32_t _internal_rotateaxisy() const;
  void _internal_set_rotateaxisy(uint32_t value);
  public:

  // uint32 posX = 3;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 posY = 4;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // uint32 posZ = 5;
  void clear_posz();
  uint32_t posz() const;
  void set_posz(uint32_t value);
  private:
  uint32_t _internal_posz() const;
  void _internal_set_posz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SC_Sync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t rotateaxisy_;
    uint32_t posx_;
    uint32_t posy_;
    uint32_t posz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CS_OnAccept

// string name = 1;
inline void CS_OnAccept::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CS_OnAccept::name() const {
  // @@protoc_insertion_point(field_get:game.CS_OnAccept.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_OnAccept::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.CS_OnAccept.name)
}
inline std::string* CS_OnAccept::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.CS_OnAccept.name)
  return _s;
}
inline const std::string& CS_OnAccept::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CS_OnAccept::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_OnAccept::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_OnAccept::release_name() {
  // @@protoc_insertion_point(field_release:game.CS_OnAccept.name)
  return _impl_.name_.Release();
}
inline void CS_OnAccept::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.CS_OnAccept.name)
}

// -------------------------------------------------------------------

// SC_CreateMyCharacter

// uint32 id = 1;
inline void SC_CreateMyCharacter::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_CreateMyCharacter::id() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.id)
  return _internal_id();
}
inline void SC_CreateMyCharacter::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_CreateMyCharacter::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.id)
}

// uint32 posX = 2;
inline void SC_CreateMyCharacter::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_CreateMyCharacter::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.posX)
  return _internal_posx();
}
inline void SC_CreateMyCharacter::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_CreateMyCharacter::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.posX)
}

// uint32 posY = 3;
inline void SC_CreateMyCharacter::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_CreateMyCharacter::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.posY)
  return _internal_posy();
}
inline void SC_CreateMyCharacter::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_CreateMyCharacter::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.posY)
}

// uint32 posZ = 4;
inline void SC_CreateMyCharacter::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_CreateMyCharacter::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.posZ)
  return _internal_posz();
}
inline void SC_CreateMyCharacter::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_CreateMyCharacter::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.posZ)
}

// uint32 rotateX = 5;
inline void SC_CreateMyCharacter::clear_rotatex() {
  _impl_.rotatex_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_rotatex() const {
  return _impl_.rotatex_;
}
inline uint32_t SC_CreateMyCharacter::rotatex() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.rotateX)
  return _internal_rotatex();
}
inline void SC_CreateMyCharacter::_internal_set_rotatex(uint32_t value) {
  
  _impl_.rotatex_ = value;
}
inline void SC_CreateMyCharacter::set_rotatex(uint32_t value) {
  _internal_set_rotatex(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.rotateX)
}

// uint32 rotateY = 6;
inline void SC_CreateMyCharacter::clear_rotatey() {
  _impl_.rotatey_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_rotatey() const {
  return _impl_.rotatey_;
}
inline uint32_t SC_CreateMyCharacter::rotatey() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.rotateY)
  return _internal_rotatey();
}
inline void SC_CreateMyCharacter::_internal_set_rotatey(uint32_t value) {
  
  _impl_.rotatey_ = value;
}
inline void SC_CreateMyCharacter::set_rotatey(uint32_t value) {
  _internal_set_rotatey(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.rotateY)
}

// uint32 rotateZ = 7;
inline void SC_CreateMyCharacter::clear_rotatez() {
  _impl_.rotatez_ = 0u;
}
inline uint32_t SC_CreateMyCharacter::_internal_rotatez() const {
  return _impl_.rotatez_;
}
inline uint32_t SC_CreateMyCharacter::rotatez() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.rotateZ)
  return _internal_rotatez();
}
inline void SC_CreateMyCharacter::_internal_set_rotatez(uint32_t value) {
  
  _impl_.rotatez_ = value;
}
inline void SC_CreateMyCharacter::set_rotatez(uint32_t value) {
  _internal_set_rotatez(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.rotateZ)
}

// string name = 8;
inline void SC_CreateMyCharacter::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SC_CreateMyCharacter::name() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateMyCharacter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_CreateMyCharacter::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SC_CreateMyCharacter.name)
}
inline std::string* SC_CreateMyCharacter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.SC_CreateMyCharacter.name)
  return _s;
}
inline const std::string& SC_CreateMyCharacter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SC_CreateMyCharacter::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_CreateMyCharacter::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_CreateMyCharacter::release_name() {
  // @@protoc_insertion_point(field_release:game.SC_CreateMyCharacter.name)
  return _impl_.name_.Release();
}
inline void SC_CreateMyCharacter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SC_CreateMyCharacter.name)
}

// -------------------------------------------------------------------

// SC_CreateOtherCharacter

// uint32 id = 1;
inline void SC_CreateOtherCharacter::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_CreateOtherCharacter::id() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.id)
  return _internal_id();
}
inline void SC_CreateOtherCharacter::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_CreateOtherCharacter::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.id)
}

// uint32 posX = 2;
inline void SC_CreateOtherCharacter::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_CreateOtherCharacter::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.posX)
  return _internal_posx();
}
inline void SC_CreateOtherCharacter::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_CreateOtherCharacter::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.posX)
}

// uint32 posY = 3;
inline void SC_CreateOtherCharacter::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_CreateOtherCharacter::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.posY)
  return _internal_posy();
}
inline void SC_CreateOtherCharacter::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_CreateOtherCharacter::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.posY)
}

// uint32 posZ = 4;
inline void SC_CreateOtherCharacter::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_CreateOtherCharacter::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.posZ)
  return _internal_posz();
}
inline void SC_CreateOtherCharacter::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_CreateOtherCharacter::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.posZ)
}

// uint32 rotateX = 5;
inline void SC_CreateOtherCharacter::clear_rotatex() {
  _impl_.rotatex_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_rotatex() const {
  return _impl_.rotatex_;
}
inline uint32_t SC_CreateOtherCharacter::rotatex() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.rotateX)
  return _internal_rotatex();
}
inline void SC_CreateOtherCharacter::_internal_set_rotatex(uint32_t value) {
  
  _impl_.rotatex_ = value;
}
inline void SC_CreateOtherCharacter::set_rotatex(uint32_t value) {
  _internal_set_rotatex(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.rotateX)
}

// uint32 rotateY = 6;
inline void SC_CreateOtherCharacter::clear_rotatey() {
  _impl_.rotatey_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_rotatey() const {
  return _impl_.rotatey_;
}
inline uint32_t SC_CreateOtherCharacter::rotatey() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.rotateY)
  return _internal_rotatey();
}
inline void SC_CreateOtherCharacter::_internal_set_rotatey(uint32_t value) {
  
  _impl_.rotatey_ = value;
}
inline void SC_CreateOtherCharacter::set_rotatey(uint32_t value) {
  _internal_set_rotatey(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.rotateY)
}

// uint32 rotateZ = 7;
inline void SC_CreateOtherCharacter::clear_rotatez() {
  _impl_.rotatez_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_rotatez() const {
  return _impl_.rotatez_;
}
inline uint32_t SC_CreateOtherCharacter::rotatez() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.rotateZ)
  return _internal_rotatez();
}
inline void SC_CreateOtherCharacter::_internal_set_rotatez(uint32_t value) {
  
  _impl_.rotatez_ = value;
}
inline void SC_CreateOtherCharacter::set_rotatez(uint32_t value) {
  _internal_set_rotatez(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.rotateZ)
}

// uint32 hp = 8;
inline void SC_CreateOtherCharacter::clear_hp() {
  _impl_.hp_ = 0u;
}
inline uint32_t SC_CreateOtherCharacter::_internal_hp() const {
  return _impl_.hp_;
}
inline uint32_t SC_CreateOtherCharacter::hp() const {
  // @@protoc_insertion_point(field_get:game.SC_CreateOtherCharacter.hp)
  return _internal_hp();
}
inline void SC_CreateOtherCharacter::_internal_set_hp(uint32_t value) {
  
  _impl_.hp_ = value;
}
inline void SC_CreateOtherCharacter::set_hp(uint32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:game.SC_CreateOtherCharacter.hp)
}

// -------------------------------------------------------------------

// SC_DeleteCharacter

// uint32 id = 1;
inline void SC_DeleteCharacter::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_DeleteCharacter::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_DeleteCharacter::id() const {
  // @@protoc_insertion_point(field_get:game.SC_DeleteCharacter.id)
  return _internal_id();
}
inline void SC_DeleteCharacter::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_DeleteCharacter::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_DeleteCharacter.id)
}

// -------------------------------------------------------------------

// CS_MoveStart

// uint32 rotateAxisY = 1;
inline void CS_MoveStart::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t CS_MoveStart::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void CS_MoveStart::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void CS_MoveStart::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.rotateAxisY)
}

// uint32 keyW = 2;
inline void CS_MoveStart::clear_keyw() {
  _impl_.keyw_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_keyw() const {
  return _impl_.keyw_;
}
inline uint32_t CS_MoveStart::keyw() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.keyW)
  return _internal_keyw();
}
inline void CS_MoveStart::_internal_set_keyw(uint32_t value) {
  
  _impl_.keyw_ = value;
}
inline void CS_MoveStart::set_keyw(uint32_t value) {
  _internal_set_keyw(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.keyW)
}

// uint32 keyA = 3;
inline void CS_MoveStart::clear_keya() {
  _impl_.keya_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_keya() const {
  return _impl_.keya_;
}
inline uint32_t CS_MoveStart::keya() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.keyA)
  return _internal_keya();
}
inline void CS_MoveStart::_internal_set_keya(uint32_t value) {
  
  _impl_.keya_ = value;
}
inline void CS_MoveStart::set_keya(uint32_t value) {
  _internal_set_keya(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.keyA)
}

// uint32 keyS = 4;
inline void CS_MoveStart::clear_keys() {
  _impl_.keys_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_keys() const {
  return _impl_.keys_;
}
inline uint32_t CS_MoveStart::keys() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.keyS)
  return _internal_keys();
}
inline void CS_MoveStart::_internal_set_keys(uint32_t value) {
  
  _impl_.keys_ = value;
}
inline void CS_MoveStart::set_keys(uint32_t value) {
  _internal_set_keys(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.keyS)
}

// uint32 keyD = 5;
inline void CS_MoveStart::clear_keyd() {
  _impl_.keyd_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_keyd() const {
  return _impl_.keyd_;
}
inline uint32_t CS_MoveStart::keyd() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.keyD)
  return _internal_keyd();
}
inline void CS_MoveStart::_internal_set_keyd(uint32_t value) {
  
  _impl_.keyd_ = value;
}
inline void CS_MoveStart::set_keyd(uint32_t value) {
  _internal_set_keyd(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.keyD)
}

// uint32 posX = 6;
inline void CS_MoveStart::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t CS_MoveStart::posx() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.posX)
  return _internal_posx();
}
inline void CS_MoveStart::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void CS_MoveStart::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.posX)
}

// uint32 posY = 7;
inline void CS_MoveStart::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t CS_MoveStart::posy() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.posY)
  return _internal_posy();
}
inline void CS_MoveStart::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void CS_MoveStart::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.posY)
}

// uint32 posZ = 8;
inline void CS_MoveStart::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t CS_MoveStart::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t CS_MoveStart::posz() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStart.posZ)
  return _internal_posz();
}
inline void CS_MoveStart::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void CS_MoveStart::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStart.posZ)
}

// -------------------------------------------------------------------

// SC_MoveStart

// uint32 id = 1;
inline void SC_MoveStart::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_MoveStart::id() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.id)
  return _internal_id();
}
inline void SC_MoveStart::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_MoveStart::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.id)
}

// uint32 rotateAxisY = 2;
inline void SC_MoveStart::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t SC_MoveStart::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void SC_MoveStart::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void SC_MoveStart::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.rotateAxisY)
}

// uint32 keyW = 3;
inline void SC_MoveStart::clear_keyw() {
  _impl_.keyw_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_keyw() const {
  return _impl_.keyw_;
}
inline uint32_t SC_MoveStart::keyw() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.keyW)
  return _internal_keyw();
}
inline void SC_MoveStart::_internal_set_keyw(uint32_t value) {
  
  _impl_.keyw_ = value;
}
inline void SC_MoveStart::set_keyw(uint32_t value) {
  _internal_set_keyw(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.keyW)
}

// uint32 keyA = 4;
inline void SC_MoveStart::clear_keya() {
  _impl_.keya_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_keya() const {
  return _impl_.keya_;
}
inline uint32_t SC_MoveStart::keya() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.keyA)
  return _internal_keya();
}
inline void SC_MoveStart::_internal_set_keya(uint32_t value) {
  
  _impl_.keya_ = value;
}
inline void SC_MoveStart::set_keya(uint32_t value) {
  _internal_set_keya(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.keyA)
}

// uint32 keyS = 5;
inline void SC_MoveStart::clear_keys() {
  _impl_.keys_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_keys() const {
  return _impl_.keys_;
}
inline uint32_t SC_MoveStart::keys() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.keyS)
  return _internal_keys();
}
inline void SC_MoveStart::_internal_set_keys(uint32_t value) {
  
  _impl_.keys_ = value;
}
inline void SC_MoveStart::set_keys(uint32_t value) {
  _internal_set_keys(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.keyS)
}

// uint32 keyD = 6;
inline void SC_MoveStart::clear_keyd() {
  _impl_.keyd_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_keyd() const {
  return _impl_.keyd_;
}
inline uint32_t SC_MoveStart::keyd() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.keyD)
  return _internal_keyd();
}
inline void SC_MoveStart::_internal_set_keyd(uint32_t value) {
  
  _impl_.keyd_ = value;
}
inline void SC_MoveStart::set_keyd(uint32_t value) {
  _internal_set_keyd(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.keyD)
}

// uint32 posX = 7;
inline void SC_MoveStart::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_MoveStart::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.posX)
  return _internal_posx();
}
inline void SC_MoveStart::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_MoveStart::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.posX)
}

// uint32 posY = 8;
inline void SC_MoveStart::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_MoveStart::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.posY)
  return _internal_posy();
}
inline void SC_MoveStart::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_MoveStart::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.posY)
}

// uint32 posZ = 9;
inline void SC_MoveStart::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_MoveStart::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_MoveStart::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStart.posZ)
  return _internal_posz();
}
inline void SC_MoveStart::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_MoveStart::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStart.posZ)
}

// -------------------------------------------------------------------

// CS_MoveStop

// uint32 rotateAxisY = 1;
inline void CS_MoveStop::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t CS_MoveStop::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t CS_MoveStop::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStop.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void CS_MoveStop::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void CS_MoveStop::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStop.rotateAxisY)
}

// uint32 posX = 2;
inline void CS_MoveStop::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t CS_MoveStop::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t CS_MoveStop::posx() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStop.posX)
  return _internal_posx();
}
inline void CS_MoveStop::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void CS_MoveStop::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStop.posX)
}

// uint32 posY = 3;
inline void CS_MoveStop::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t CS_MoveStop::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t CS_MoveStop::posy() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStop.posY)
  return _internal_posy();
}
inline void CS_MoveStop::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void CS_MoveStop::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStop.posY)
}

// uint32 posZ = 4;
inline void CS_MoveStop::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t CS_MoveStop::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t CS_MoveStop::posz() const {
  // @@protoc_insertion_point(field_get:game.CS_MoveStop.posZ)
  return _internal_posz();
}
inline void CS_MoveStop::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void CS_MoveStop::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.CS_MoveStop.posZ)
}

// -------------------------------------------------------------------

// SC_MoveStop

// uint32 id = 1;
inline void SC_MoveStop::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_MoveStop::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_MoveStop::id() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStop.id)
  return _internal_id();
}
inline void SC_MoveStop::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_MoveStop::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStop.id)
}

// uint32 rotateAxisY = 2;
inline void SC_MoveStop::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t SC_MoveStop::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t SC_MoveStop::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStop.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void SC_MoveStop::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void SC_MoveStop::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStop.rotateAxisY)
}

// uint32 posX = 3;
inline void SC_MoveStop::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_MoveStop::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_MoveStop::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStop.posX)
  return _internal_posx();
}
inline void SC_MoveStop::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_MoveStop::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStop.posX)
}

// uint32 posY = 4;
inline void SC_MoveStop::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_MoveStop::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_MoveStop::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStop.posY)
  return _internal_posy();
}
inline void SC_MoveStop::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_MoveStop::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStop.posY)
}

// uint32 posZ = 5;
inline void SC_MoveStop::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_MoveStop::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_MoveStop::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_MoveStop.posZ)
  return _internal_posz();
}
inline void SC_MoveStop::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_MoveStop::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_MoveStop.posZ)
}

// -------------------------------------------------------------------

// CS_ChangeWeapon

// uint32 weapon = 1;
inline void CS_ChangeWeapon::clear_weapon() {
  _impl_.weapon_ = 0u;
}
inline uint32_t CS_ChangeWeapon::_internal_weapon() const {
  return _impl_.weapon_;
}
inline uint32_t CS_ChangeWeapon::weapon() const {
  // @@protoc_insertion_point(field_get:game.CS_ChangeWeapon.weapon)
  return _internal_weapon();
}
inline void CS_ChangeWeapon::_internal_set_weapon(uint32_t value) {
  
  _impl_.weapon_ = value;
}
inline void CS_ChangeWeapon::set_weapon(uint32_t value) {
  _internal_set_weapon(value);
  // @@protoc_insertion_point(field_set:game.CS_ChangeWeapon.weapon)
}

// -------------------------------------------------------------------

// SC_ChangeWeapon

// uint32 id = 1;
inline void SC_ChangeWeapon::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_ChangeWeapon::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_ChangeWeapon::id() const {
  // @@protoc_insertion_point(field_get:game.SC_ChangeWeapon.id)
  return _internal_id();
}
inline void SC_ChangeWeapon::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_ChangeWeapon::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_ChangeWeapon.id)
}

// uint32 weapon = 2;
inline void SC_ChangeWeapon::clear_weapon() {
  _impl_.weapon_ = 0u;
}
inline uint32_t SC_ChangeWeapon::_internal_weapon() const {
  return _impl_.weapon_;
}
inline uint32_t SC_ChangeWeapon::weapon() const {
  // @@protoc_insertion_point(field_get:game.SC_ChangeWeapon.weapon)
  return _internal_weapon();
}
inline void SC_ChangeWeapon::_internal_set_weapon(uint32_t value) {
  
  _impl_.weapon_ = value;
}
inline void SC_ChangeWeapon::set_weapon(uint32_t value) {
  _internal_set_weapon(value);
  // @@protoc_insertion_point(field_set:game.SC_ChangeWeapon.weapon)
}

// -------------------------------------------------------------------

// CS_Attack

// uint32 targetId = 1;
inline void CS_Attack::clear_targetid() {
  _impl_.targetid_ = 0u;
}
inline uint32_t CS_Attack::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint32_t CS_Attack::targetid() const {
  // @@protoc_insertion_point(field_get:game.CS_Attack.targetId)
  return _internal_targetid();
}
inline void CS_Attack::_internal_set_targetid(uint32_t value) {
  
  _impl_.targetid_ = value;
}
inline void CS_Attack::set_targetid(uint32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:game.CS_Attack.targetId)
}

// bool attackSuccess = 2;
inline void CS_Attack::clear_attacksuccess() {
  _impl_.attacksuccess_ = false;
}
inline bool CS_Attack::_internal_attacksuccess() const {
  return _impl_.attacksuccess_;
}
inline bool CS_Attack::attacksuccess() const {
  // @@protoc_insertion_point(field_get:game.CS_Attack.attackSuccess)
  return _internal_attacksuccess();
}
inline void CS_Attack::_internal_set_attacksuccess(bool value) {
  
  _impl_.attacksuccess_ = value;
}
inline void CS_Attack::set_attacksuccess(bool value) {
  _internal_set_attacksuccess(value);
  // @@protoc_insertion_point(field_set:game.CS_Attack.attackSuccess)
}

// -------------------------------------------------------------------

// SC_Attack

// uint32 id = 1;
inline void SC_Attack::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_Attack::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_Attack::id() const {
  // @@protoc_insertion_point(field_get:game.SC_Attack.id)
  return _internal_id();
}
inline void SC_Attack::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_Attack::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_Attack.id)
}

// uint32 rotateAxisY = 2;
inline void SC_Attack::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t SC_Attack::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t SC_Attack::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.SC_Attack.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void SC_Attack::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void SC_Attack::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.SC_Attack.rotateAxisY)
}

// uint32 posX = 3;
inline void SC_Attack::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_Attack::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_Attack::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_Attack.posX)
  return _internal_posx();
}
inline void SC_Attack::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_Attack::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_Attack.posX)
}

// uint32 posY = 4;
inline void SC_Attack::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_Attack::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_Attack::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_Attack.posY)
  return _internal_posy();
}
inline void SC_Attack::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_Attack::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_Attack.posY)
}

// uint32 posZ = 5;
inline void SC_Attack::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_Attack::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_Attack::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_Attack.posZ)
  return _internal_posz();
}
inline void SC_Attack::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_Attack::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_Attack.posZ)
}

// -------------------------------------------------------------------

// SC_Damage

// uint32 attackerId = 1;
inline void SC_Damage::clear_attackerid() {
  _impl_.attackerid_ = 0u;
}
inline uint32_t SC_Damage::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline uint32_t SC_Damage::attackerid() const {
  // @@protoc_insertion_point(field_get:game.SC_Damage.attackerId)
  return _internal_attackerid();
}
inline void SC_Damage::_internal_set_attackerid(uint32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void SC_Damage::set_attackerid(uint32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:game.SC_Damage.attackerId)
}

// uint32 targetId = 2;
inline void SC_Damage::clear_targetid() {
  _impl_.targetid_ = 0u;
}
inline uint32_t SC_Damage::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint32_t SC_Damage::targetid() const {
  // @@protoc_insertion_point(field_get:game.SC_Damage.targetId)
  return _internal_targetid();
}
inline void SC_Damage::_internal_set_targetid(uint32_t value) {
  
  _impl_.targetid_ = value;
}
inline void SC_Damage::set_targetid(uint32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:game.SC_Damage.targetId)
}

// uint32 damageHP = 3;
inline void SC_Damage::clear_damagehp() {
  _impl_.damagehp_ = 0u;
}
inline uint32_t SC_Damage::_internal_damagehp() const {
  return _impl_.damagehp_;
}
inline uint32_t SC_Damage::damagehp() const {
  // @@protoc_insertion_point(field_get:game.SC_Damage.damageHP)
  return _internal_damagehp();
}
inline void SC_Damage::_internal_set_damagehp(uint32_t value) {
  
  _impl_.damagehp_ = value;
}
inline void SC_Damage::set_damagehp(uint32_t value) {
  _internal_set_damagehp(value);
  // @@protoc_insertion_point(field_set:game.SC_Damage.damageHP)
}

// -------------------------------------------------------------------

// CS_Sync

// uint32 rotateAxisY = 1;
inline void CS_Sync::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t CS_Sync::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t CS_Sync::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.CS_Sync.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void CS_Sync::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void CS_Sync::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.CS_Sync.rotateAxisY)
}

// uint32 posX = 2;
inline void CS_Sync::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t CS_Sync::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t CS_Sync::posx() const {
  // @@protoc_insertion_point(field_get:game.CS_Sync.posX)
  return _internal_posx();
}
inline void CS_Sync::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void CS_Sync::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.CS_Sync.posX)
}

// uint32 posY = 3;
inline void CS_Sync::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t CS_Sync::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t CS_Sync::posy() const {
  // @@protoc_insertion_point(field_get:game.CS_Sync.posY)
  return _internal_posy();
}
inline void CS_Sync::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void CS_Sync::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.CS_Sync.posY)
}

// uint32 posZ = 4;
inline void CS_Sync::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t CS_Sync::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t CS_Sync::posz() const {
  // @@protoc_insertion_point(field_get:game.CS_Sync.posZ)
  return _internal_posz();
}
inline void CS_Sync::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void CS_Sync::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.CS_Sync.posZ)
}

// -------------------------------------------------------------------

// SC_Sync

// uint32 id = 1;
inline void SC_Sync::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SC_Sync::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SC_Sync::id() const {
  // @@protoc_insertion_point(field_get:game.SC_Sync.id)
  return _internal_id();
}
inline void SC_Sync::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_Sync::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SC_Sync.id)
}

// uint32 rotateAxisY = 2;
inline void SC_Sync::clear_rotateaxisy() {
  _impl_.rotateaxisy_ = 0u;
}
inline uint32_t SC_Sync::_internal_rotateaxisy() const {
  return _impl_.rotateaxisy_;
}
inline uint32_t SC_Sync::rotateaxisy() const {
  // @@protoc_insertion_point(field_get:game.SC_Sync.rotateAxisY)
  return _internal_rotateaxisy();
}
inline void SC_Sync::_internal_set_rotateaxisy(uint32_t value) {
  
  _impl_.rotateaxisy_ = value;
}
inline void SC_Sync::set_rotateaxisy(uint32_t value) {
  _internal_set_rotateaxisy(value);
  // @@protoc_insertion_point(field_set:game.SC_Sync.rotateAxisY)
}

// uint32 posX = 3;
inline void SC_Sync::clear_posx() {
  _impl_.posx_ = 0u;
}
inline uint32_t SC_Sync::_internal_posx() const {
  return _impl_.posx_;
}
inline uint32_t SC_Sync::posx() const {
  // @@protoc_insertion_point(field_get:game.SC_Sync.posX)
  return _internal_posx();
}
inline void SC_Sync::_internal_set_posx(uint32_t value) {
  
  _impl_.posx_ = value;
}
inline void SC_Sync::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:game.SC_Sync.posX)
}

// uint32 posY = 4;
inline void SC_Sync::clear_posy() {
  _impl_.posy_ = 0u;
}
inline uint32_t SC_Sync::_internal_posy() const {
  return _impl_.posy_;
}
inline uint32_t SC_Sync::posy() const {
  // @@protoc_insertion_point(field_get:game.SC_Sync.posY)
  return _internal_posy();
}
inline void SC_Sync::_internal_set_posy(uint32_t value) {
  
  _impl_.posy_ = value;
}
inline void SC_Sync::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:game.SC_Sync.posY)
}

// uint32 posZ = 5;
inline void SC_Sync::clear_posz() {
  _impl_.posz_ = 0u;
}
inline uint32_t SC_Sync::_internal_posz() const {
  return _impl_.posz_;
}
inline uint32_t SC_Sync::posz() const {
  // @@protoc_insertion_point(field_get:game.SC_Sync.posZ)
  return _internal_posz();
}
inline void SC_Sync::_internal_set_posz(uint32_t value) {
  
  _impl_.posz_ = value;
}
inline void SC_Sync::set_posz(uint32_t value) {
  _internal_set_posz(value);
  // @@protoc_insertion_point(field_set:game.SC_Sync.posZ)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::PacketID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::PacketID>() {
  return ::game::PacketID_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
